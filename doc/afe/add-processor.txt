.. _sec-afe-add-processor:

Add your own processors
=======================

.. vim: filetype=rst spell:

The |AFE| framework has been designed such as to be easily upgraded. To add a 
new processor, write its class definition in a new ``.m`` file and add it to 
the ``/src/Processors`` folder. If correctly written, the processor should be 
detected by the framework and be ready to use. This section documents in 
details how to correctly write the class definition of a new processor. It is 
highly recommended to look into the definition of existing processors to get 
a grasp of how classes are defined and written in Matlab. In the following, we 
will sometimes refer to a particular existing processor to illustrate some 
aspects of the implementation.

.. note::
    
    The following descriptions are exhaustive, and adding a processor to the
    framework is actually easier than the length of this page suggests! Having a
    thorough look through the code of existing processors and some understanding
    of object-oriented coding in Matlab should make the process relatively
    painless.

.. _sec-afe-addition-checklist:

Check-list for adding a new processor
-------------------------------------

To write the class definition for a new processor such that it will be 
recognised and properly integrated, one has to follow these steps:

1. :ref:`Set up the specific properties of the processor class <sec-afe-class-properties>`
#. :ref:`Implement the processor's static methods <sec-afe-static-methods>`
#. :ref:`Implement the processor's abstract methods (processing and resetting) <sec-afe-processing-method>`
#. :ref:`Implementing parameters "getter" methods <sec-afe-getter-methods>`
#. Override parent methods (optional)
#. :ref:`Add a new type of signal (optional)<sec-afe-new-signal>`
#. Allowing alternative processing options (optional)

.. _sec-afe-class-properties:

Getting started and setting up processor properties
---------------------------------------------------

The properties of an object are a way to store data used by the object. There
are two types of properties for processors, those which:

- store all the parameters needed to integrate the processor in the framework 
  (e.g., the sampling frequency on which it operates, the number of 
  inputs/outputs, ...)
- store parameter values which are used in the actual processing

When writing the class definition for a new processor, it is only necessary to
implement the latter: parameters which are needed in the computation. All
parameters needed for the integration of the processor in the framework are
already defined in the parent ``Processor`` class. Your new processor should
inherit this parent class in order to automatically have access to the
properties and methods of the parent class. Inheritance in Matlab is indicated
by the command ``< nameOfParentClass`` following the name of your new class on
the first line of its definition.

.. Maybe we could set up a template file, as a blank processor with basic guidelines on how to populate the blanks

The new processor class definition should be saved in a ``.m`` file that bears
the same name as the defined class. In the example below, that would be
``myNewProcessor.m``.

There are usually two categories of properties to implement for a new processor:
external (user-controlled) parameters and internal parameters necessary for the
processor but which do not need to be known to the "outside world".

.. note::

    Only the two types of properties below have been used so far in every
    processor implementation. However, it is fine to add more if needed for your
    new processor.

External parameters controllable by the user
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

External parameters are directly related to the parameters the user has control
upon. The actual values for these are stored in a specific object accessible via
the ``.parameters`` property of the processor. Defining them as individual
properties seems redundant, and is therefore optional. However it can be very
convenient in order to simplify the access to the parameter value and to make
your code more readable.

Instead of storing an actual value, the corresponding processor property should
only point to a value in the ``.parameters`` object. This will avoid having two
different values for a same parameter. To do this, external parameters should be
defined as a set of dependent properties. This is indicated by the ``Dependent =
true`` property attribute. If a property is set to ``Dependent``, then a
corresponding "getter" method has to be implemented for it. This will be
developed :ref:`in a following section<sec-afe-getter-methods>`. For example,
if your new processor has two parameters, ``parA`` and ``parB``, you can define
these as properties as follow::


    classdef myNewProcessor < Processor

      properties (Dependent = true)
        parA;
        parB;
      end

      %...

    end

This will allow easier access to these values in your code. For example,
``myNewProcessor.parA`` will always give the same output as
``myNewProcessor.parameters.map('nameTagOfParameterA')``, even if the parameter
value changes due to feedback. This simplifies greatly the code, particularly
when many parameters are involved.


Internal parameters
~~~~~~~~~~~~~~~~~~~

Internal parameters are sometimes (not always) needed for the good functioning
of the processor. They are typically used to store internal states of the
processor (to allow continuity in block-based processing), filter instances (if
your processor involves filtering), or just intermediate parameter values used
to make code more readable.

Because they are "internal" to the processor, these parameters are usually
stored as a set of private properties by using the ``GetAccess = private``
property attributes. This will virtually make the property invisible and
inaccessible to all other objects.

.. _sec-afe-static-methods:

Implementing static methods
---------------------------

Static methods are methods that can be called without an existing instance of an
object. In the implementation of processors, they are used to store all the
hard-coded information. This can be for example the processor name, the type of
signal it accepts as input, or the names and default values of its external
parameters. To implement a static method, define it in a method block with the
``(Static)`` method attribute::


    classdef myNewProcessor < Processor

      % ... Properties and other methods definition

      methods (Static)

        function out = myStaticMethod_1(in)
          %...
        end

        function out = myStaticMethod_2(in)
          %...
        end

      end

    end

Static methods share the same structure and names across processors, so they can
easily be copy/pasted from an existing processor and then modified to reflect
your new processor. The following three methods have to be implemented.

- ``.getDependency()``: Returns the type of input signal by its user request 
  name
- ``.getParameterInfo()``: Returns names, default values, and descriptions of 
  external parameters
- ``.getProcessorInfo()``: Returns information about the processor as a Matlab 
  structure

As they are used to hard-code and return information, none of these methods 
accept input arguments.

``getDependency``
~~~~~~~~~~~~~~~~

This method returns the type of input signal your processor should accept::

    function name = getDependency()
      name = 'requestNameOfInputSignal';
    end

where ``'requestNameOfInputSignal'`` is the request name of the signal that
should be used as input. "Request name" corresponds to the request a user would
call in order to obtain that signal. For example, the inner hair-cell envelope
processor requires as input the output of e.g., a gammatone filterbank. The
request name for this signal is ``'filterbank'`` which should therefore be the
output of the static method ``ihcProc.getDependency()``.

If you are unsure about which name should be used, consider which processor
would come directly before your new processor in a processing chain (i.e., the
processor your new processor depends on). Say it is named ``dependentProc``.
Then typing::

    dependentProc.getProcessorInfo.requestName

in Matlab's command window will return the corresponding request name you should
output in your ``getDependency`` method.

``getParameterInfo``
~~~~~~~~~~~~~~~~~~~~

This method hard-codes all information regarding the (external) parameters used
by your processor, i.e., lists of their names, default values, and description.
These are used to populate the output of the helper script ``parameterHelper``
and to give a default value to parameters when your processor is instantiated.

The lists are returned as cell arrays of strings (or any other type for the
default parameter values). They should follow the same order, such that the n-th
member of each of the three lists relate to the same parameter.

Parameter names need not be the same as the parameter properties names you
defined :ref:`earlier<sec-afe-class-properties>`. This will become apparent in
the next section. In fact, names should be changed to at least include a two or
three letters prefix that is unique to your new processor. You can make sure it
is not already in use by browsing through the output of the ``parameterHelper``
script.

The method should look something like this::

    function [names,defValues,description] = getParameterInfo()

      names = {'xx_par1','xx_par2','xx_par3'};

      defValues = {0.5, ...
                   [1 2 3 4], ...
                   'someStringValue'};

      description = {'Tuning factor of dummy example (s)',...
                     'Vector of unused frequencies (Hz)',...
                     'Model name ('someStringValue' or 'anotherValue')}

    end

This dummy example illustrates the following important points:
- Use a unique prefix in the name of the parameters (``xx_`` above) that 
  abbreviates the name or task of the processor.
- Find a short, but self-explanatory parameter name (*not* like above). If it
  makes sense, you can re-use the same name as a parameter involved in another 
  processor. The prefix will make the name unique.
- Default values can be of any type (e.g., float number, array, strings,...)
- Descriptions should be as short as possible while still explanatory. Mention 
  if applicable the units or the different alternatives.

``getProcessorInfo``
~~~~~~~~~~~~~~~~~~~~

This method stores the properties of the processor that are needed to integrate
it in the framework. It outputs a structure with the following fields:

- ``.name``: A short, self-explanatory name for the processor
- ``.label``: A name for the processor that is used as a label. It can the same 
  as ``.name`` if that is sufficient, or a bit longer if needed.
- ``.requestName``: The name tag of the request that a user should input when 
  calling the ``.addProcessor`` method of the manager. *Cannot* include spaces.
- ``.requestLabel``: A longer name for the signal this processor produces, used 
  e.g., as plot labels.
- ``outputType``: The type of signal object (name of the class) this processor 
  produces. If none of the existing signals in the framework are suitable, you 
  will need to :ref:`implement a new one<sec-afe-new-signal>`.
- ``isBinaural``: Set to 0 if your processor operates on a single channel or to 
  1 if it *needs* a binaural input. If your processor can indifferently operate
  on mono or stereo signals (such as the pre-processor ``preProc.m``), set to 2.

.. _sec-afe-getter-methods:

Implementing parameters "getter" methods
----------------------------------------

.. _sec-afe-processing-method:

Implement the processor's abstract methods
------------------------------------------


.. _sec-afe-new-signal:

Implement a new signal type
---------------------------