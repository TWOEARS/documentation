.. _sec-afe-add-processor:

Add your own processors
=======================

.. vim: filetype=rst spell:

The |AFE| framework has been designed such as to be easily upgraded. To add a 
new processor, write its class definition in a new ``.m`` file and add it to 
the ``/src/Processors`` folder. If correctly written, the processor should be 
detected by the framework and be ready to use. This section documents in 
details how to correctly write the class definition of a new processor. It is 
highly recommended to look into the definition of existing processors to get 
a grasp of how classes are defined and written in Matlab. In the following, we 
will sometimes refer to a particular existing processor to illustrate some 
aspects of the implementation.

.. note::
    
    - The following descriptions are exhaustive, and adding a processor to the
      framework is actually easier than the length of this page suggests!
    - This tutorial is written assuming close to no knowledge about object-
      oriented programming using Matlab. Hence most 
      :abbr:`OOP(object-oriented programming)` concepts involved are briefly 
      explained. If you are already familiar with them, then the process should 
      be relatively painless.

.. _sec-afe-addition-checklist:

Check-list for adding a new processor
-------------------------------------

To write the class definition for a new processor such that it will be 
recognised and properly integrated, one has to follow these steps:

1. :ref:`Set up the specific properties of the processor class <sec-afe-class-properties>`
#. :ref:`Implement the processor's static methods <sec-afe-static-methods>`
#. :ref:`Implement the processor's abstract methods (processing and resetting) <sec-afe-processing-method>`
#. :ref:`Implementing parameters "getter" methods <sec-afe-getter-methods>`
#. :ref:`Implement the processor constructor <sec-afe-processor-constructor>`
#. :ref:`Take a break and test your implementation <sec-afe-preliminary-testing>`
#. :ref:`Implement the core processing method <sec-afe-processing-method>`
#. :ref:`Override parent methods (optional) <sec-afe-override-methods>`
#. :ref:`Allowing alternative processing options (optional) <sec-afe-alternative-processing>`
#. :ref:`Add a new type of signal (optional)<sec-afe-new-signal>`
#. :ref:`Final testing <sec-afe-final-testing>`

.. _sec-afe-class-properties:

Getting started and setting up processor properties
---------------------------------------------------

The properties of an object are a way to store data used by the object. There
are two types of properties for processors, those which:

- store all the parameters needed to integrate the processor in the framework 
  (e.g., the sampling frequency on which it operates, the number of 
  inputs/outputs, ...)
- store parameter values which are used in the actual processing

When writing the class definition for a new processor, it is only necessary to
implement the latter: parameters which are needed in the computation. All
parameters needed for the integration of the processor in the framework are
already defined in the parent ``Processor`` class. Your new processor should
inherit this parent class in order to automatically have access to the
properties and methods of the parent class. Inheritance in Matlab is indicated
by the command ``< nameOfParentClass`` following the name of your new class on
the first line of its definition.

.. Maybe we could set up a template file, i.e., a blank processor with basic guidelines on how to populate the blanks

The new processor class definition should be saved in a ``.m`` file that bears
the same name as the defined class. In the example below, that would be
``myNewProcessor.m``.

There are usually two categories of properties to implement for a new processor:
external (user-controlled) parameters and internal parameters necessary for the
processor but which do not need to be known to the "outside world".

.. note::

    Only the two types of properties below have been used so far in every
    processor implementation. However, it is fine to add more if needed for your
    new processor.

External parameters controllable by the user
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

External parameters are directly related to the parameters the user has control
upon. The actual values for these are stored in a specific object accessible via
the ``.parameters`` property of the processor. Defining them as individual
properties seems redundant, and is therefore optional. However it can be very
convenient in order to simplify the access to the parameter value and to make
your code more readable.

Instead of storing an actual value, the corresponding processor property should
only point to a value in the ``.parameters`` object. This will avoid having two
different values for a same parameter. To do this, external parameters should be
defined as a set of dependent properties. This is indicated by the ``Dependent =
true`` property attribute. If a property is set to ``Dependent``, then a
corresponding "getter" method has to be implemented for it. This will be
developed :ref:`in a following section<sec-afe-getter-methods>`. For example,
if your new processor has two parameters, ``parA`` and ``parB``, you can define
these as properties as follow::


    classdef myNewProcessor < Processor

      properties (Dependent = true)
        parA;
        parB;
      end

      %...

    end

This will allow easier access to these values in your code. For example,
``myNewProcessor.parA`` will always give the same output as
``myNewProcessor.parameters.map('xx_nameTagOfParameterA')``, even if the
parameter value changes due to feedback. This simplifies greatly the code,
particularly when many parameters are involved.


Internal parameters
~~~~~~~~~~~~~~~~~~~

Internal parameters are sometimes (not always) needed for the good functioning
of the processor. They are typically used to store internal states of the
processor (to allow continuity in block-based processing), filter instances (if
your processor involves filtering), or just intermediate parameter values used
to make code more readable.

Because they are "internal" to the processor, these parameters are usually
stored as a set of private properties by using the ``GetAccess = private``
property attributes. This will virtually make the property invisible and
inaccessible to all other objects.

.. _sec-afe-static-methods:

Implementing static methods
---------------------------

Static methods are methods that can be called without an existing instance of an
object. In the implementation of processors, they are used to store all the
hard-coded information. This can be for example the processor name, the type of
signal it accepts as input, or the names and default values of its external
parameters. To implement a static method, define it in a method block with the
``(Static)`` method attribute::


    classdef myNewProcessor < Processor

      % ... Properties and other methods definition

      methods (Static)

        function out = myStaticMethod_1(in)
          %...
        end

        function out = myStaticMethod_2(in)
          %...
        end

      end

    end

Static methods share the same structure and names across processors, so they can
easily be copy/pasted from an existing processor and then modified to reflect
your new processor. The following three methods have to be implemented.

- ``.getDependency()``: Returns the type of input signal by its user request 
  name
- ``.getParameterInfo()``: Returns names, default values, and descriptions of 
  external parameters
- ``.getProcessorInfo()``: Returns information about the processor as a Matlab 
  structure

As they are used to hard-code and return information, none of these methods 
accept input arguments.

``getDependency``
~~~~~~~~~~~~~~~~~

This method returns the type of input signal your processor should accept::

    function name = getDependency()
      name = 'requestNameOfInputSignal';
    end

where ``'requestNameOfInputSignal'`` is the request name of the signal that
should be used as input. "Request name" corresponds to the request a user would
call in order to obtain that signal. For example, the inner hair-cell envelope
processor requires as input the output of e.g., a gammatone filterbank. The
request name for this signal is ``'filterbank'`` which should therefore be the
output of the static method ``ihcProc.getDependency()``.

If you are unsure about which name should be used, consider which processor
would come directly before your new processor in a processing chain (i.e., the
processor your new processor depends on). Say it is named ``dependentProc``.
Then typing::

    dependentProc.getProcessorInfo.requestName

in Matlab's command window will return the corresponding request name you should
output in your ``getDependency`` method.

``getParameterInfo``
~~~~~~~~~~~~~~~~~~~~

This method hard-codes all information regarding the (external) parameters used
by your processor, i.e., lists of their names, default values, and description.
These are used to populate the output of the helper script ``parameterHelper``
and to give a default value to parameters when your processor is instantiated.

The lists are returned as cell arrays of strings (or any other type for the
default parameter values). They should follow the same order, such that the n-th
member of each of the three lists relate to the same parameter.

Parameter names need not be the same as the parameter properties names you
defined :ref:`earlier<sec-afe-class-properties>`. This will become apparent in
the :ref:`next section<sec-afe-getter-methods>`. In fact, names should be
changed to at least include a two or three letters prefix that is unique to your
new processor. You can make sure it is not already in use by browsing through
the output of the ``parameterHelper`` script.

The method should look something like this::

    function [names,defValues,description] = getParameterInfo()

      names = {'xx_par1','xx_par2','xx_par3'};

      defValues = {0.5, ...
                   [1 2 3 4], ...
                   'someStringValue'};

      description = {'Tuning factor of dummy example (s)',...
                     'Vector of unused frequencies (Hz)',...
                     'Model name (''someStringValue'' or ''anotherValue'')'}

    end

This dummy example illustrates the following important points:

- Use a unique prefix in the name of the parameters (``xx_`` above) that 
  abbreviates the name or task of the processor.
- Find a short, but self-explanatory parameter name (*not* like ``parX`` above).
  If it makes sense, you can re-use the same name as a parameter involved in 
  another processor. The prefix will make the name unique.
- Default values can be of any type (e.g., float number, array, strings,...)
- Descriptions should be as short as possible while still explanatory. Mention 
  if applicable the units or the different alternatives.

``getProcessorInfo``
~~~~~~~~~~~~~~~~~~~~

This method stores the properties of the processor that are needed to integrate
it in the framework. It outputs a structure with the following fields:

- ``.name``: A short, self-explanatory name for the processor
- ``.label``: A name for the processor that is used as a label. It can the same 
  as ``.name`` if that is sufficient, or a bit longer if needed.
- ``.requestName``: The name tag of the request that a user should input when 
  calling the ``.addProcessor`` method of the manager. *Cannot* include spaces.
- ``.requestLabel``: A longer name for the signal this processor produces, used 
  e.g., as plot labels.
- ``outputType``: The type of signal object (name of the class) this processor 
  produces. If none of the existing signals in the framework are suitable, you 
  will need to :ref:`implement a new one<sec-afe-new-signal>`.
- ``isBinaural``: Set to 0 if your processor operates on a single channel (e.g.,
  an auditory filterbank) or to 1 if it *needs* a binaural input (e.g., the 
  inter-aural level differences processor). If your processor can indifferently 
  operate on mono or stereo signals (such as the pre-processor ``preProc.m``), 
  set to 2.

Your method should initialize the structure that will be returned as output and
give a value to all of the above-mentioned fields::

  %...

  function pInfo = getProcessorInfo

    pInfo = struct;

    pInfo.name = 'MyProcessor';
    pInfo.label = 'Processor doing things';
    % etc...

  end


.. _sec-afe-getter-methods:

Implementing parameters "getter" methods
----------------------------------------

As described in an :ref:`earlier section<sec-afe-class-properties>`, external
parameters of the processor, i.e., those that can be modified by the user, were
implemented as ``Dependent`` properties of your processor class. For your
implementation to be valid, a "getter" method needs to be implemented for each
of these parameters. If not, Matlab will generate an error when trying to access
that parameter value. If a property is set as ``Dependent``, then its getter
method will be called whenever the program try to access that property. In
general, this can be useful for a property that *depends* on others and that
need to be recomputed whenever accessed. In the present case, we will set the
getter method to read the corresponding parameter value in the parameter object
associated with your processor. If the value of the parameter has changed
throughout the processing (e.g., in response to feedback), then we are sure to
always get the updated value.

"Getter" methods for parameters are implemented without any method attribute and
always follow the same structure. Hence they can easily be copy/pasted and
adjusted::

    methods

      function value = get.parName(pObj)
        value = pObj.parameters.map('xx_parNameTag')
      end

      % ... implement one get. method for each parameter

    end

In the above example, ``parName`` is the name of the parameter as a dependent
*property* of your processor class, and ``xx_parNameTag`` is the name of the
parameter as the user accesses it and as is defined in the :ref:`static<sec-afe-static-methods>`
``.getParameterInfo`` method. ``pObj`` represents an instance of your processor
class, it does not need to be changed across methods.


.. _sec-afe-processor-constructor:

Implement the processor constructor
-----------------------------------

For any possible application, every concrete classes one defines in Matlab
should implement a very specific method: a class constructor. A class
constructor is a function that bears the exact same name as your class, that can
take any combination of input arguments but that can return only a single
output: an "instance" of your class.

In the |AFE| architecture however, the input arguments to the constructor of all
processors have been normalized, such that all processor constructors can be
called using the exact same arguments. The input arguments should be (in this
order) the sampling frequency of the input signal to the processor and an
instance of parameter object returned e.g. by the script ``genParStruct.m``. The
constructor's role is then to create an object of the class, and often to
initialize all its properties. Most of this initialization step is the same
across all processors (e.g., setting input/output sampling frequencies,
indicating the type of processor, ...). Hence all processor constructors rely
heavily on the constructor of their parent class (or super-constructor),
``Processor(...)`` which defines these across-processors operations. This allows
to have all this code in one place which reduces the code you have to write for
your processor, as well as reducing chances for bugs and increasing
maintainability. This concept of "inheritance" will be further taken advantage
of in a :ref:`further section<sec-afe-override-methods>`.

In practice, this means that the constructor for your processor will be very
short:

.. code-block:: Matlab
    :linenos:

    function pObj = myNewProcessor(fs,parObj)
      %myNewProcessor   ... Provide some help here ...

      if nargin<2||isempty(parObj); parObj = Parameters; end
      if nargin<1; fs = []; end

      % Call super-constructor
      pObj = pObj@Processor(fs, fsOut,'myNewProcessor',parObj);

      % Additional code depending on your processor
      % ...

    end


.. note::

    The constructor method should be placed in a "method" block with no method 
    attribute.

Let us break down the constructor structure line by line:

- *Line 1*: As stated earlier, all processor constructors take two input and 
  return a single output, your processor instance ``pObj``. Matlab restricts all 
  constructors to return a single output. If for any reason you need additional 
  information as output, you would have to place it in a property of your 
  processor instead of a regular output. Input arguments are the **input** 
  sampling frequency, i.e., the sampling frequency of the signal at the input of 
  the processor, and a parameter object ``parObj``.
- *Line 2*: This is where you will place help regarding how to call this 
  constructor. Because they have a generic form across all processors, you can 
  easily copy/paste it from another processor.
- *Lines 4 and 5*: An important aspect in this implementation is that the 
  constructor should be called with no input argument and still return a valid 
  instance of the processor, without any error. Hence these two lines define 
  default values for inputs if none were specified.
- *Line 8*: This line generates a processor instance by calling the class 
  super-constructor. The super-constructor takes four inputs: 

  - the **input** sampling frequency ``fs``
  - the **output** sampling frequency. If your processor does not modify the 
    sampling rate, then you can replace ``fsOut`` with ``fs``. If the output 
    sampling rate of your processor if **fixed**, i.e., not depending on 
    external parameters, then you can specify it here, in place of ``fsOut``. 
    Lastly, if the output sampling rate depends on some external parameters 
    (i.e., susceptible to change via feedback from the user), then you should 
    leave the ``fsOut`` field empty: ``[]``. The output sampling rate will be 
    defined in :ref:`another method<sec-afe-override-methods>` that is called 
    every time feedback is involved.
  - the name of the children processor, here ``myNewProcessor``.
  - the parameter object ``parObj`` already provided as input.

- *Line 11*: Your processor might need additional initialization. All extra code
  should go there. To ensure that no error is generated when calling the 
  constructor with no arguments (which Matlab sometimes does implicitly), the 
  code should be embedded in a ``if nargin > 0 ... end`` block. Here you can 
  for example initialize buffers or internal properties.

.. warning::

    The initialization of anything that depends on external parameters (e.g.,
    filters, framing windows, ...) is not performed here on line 11. When 
    parameters change due to feedback, these properties need to be 
    re-initialized. Hence their initialization is performed in another method 
    that will be described in a 
    :ref:`following section<sec-afe-override-methods>`.



.. _sec-afe-preliminary-testing:

Preliminary testing
-------------------

At this stage of the implementation, your processor should be correctly
instantiated and recognised by the framework. In some cases (e.g., your
processor is a simple single input / single output processor), it might even be
correctly integrated and routed to other processors. In any case, now is a good
time to take a break from writing code and do some preliminary testing. We will
go through a few example tests you can run, which problems could arise and some
suggestions as to how to solve them. Try to run these tests in the order they
are listed below, as this will help troubleshooting. They should run as expected
before you go further in your implementation.

.. note::   
  You will not be able to instantiate your processor before you have written a 
  concrete implementation to ``Processor`` abstract methods. To carry out the 
  tests below, just write empty ``processChunk`` and ``reset`` methods. This 
  way, Matlab will not complain about trying to instantiate a class that 
  contains abstract methods. The actual implementation of these methods will be 
  described in later sections.


Default instantiation
~~~~~~~~~~~~~~~~~~~~~

As mentioned when 
:ref:`implementing the constructor<sec-afe-processor-constructor>`, you should 
be able to get a valid instance of your processor by calling its constructor 
without any input arguments::

  >> p = myNewProcessor

If this line returns an error, then you have to revise your implementation of
the :ref:`constructor<sec-afe-processor-constructor>`. The error message should
indicate clearly enough where the problem is, so that you can easily correct it.
Note that it is necessary for this test to pass for your processor to be
integrated in the framework. If it cannot be instantiated with no arguments,
then it will not be listed as a valid processor.

If on the other hand this line executed without error, then there are two things
you should control:

1. The line above (if not ended by a semicolon) should display the visible, 
   public properties of the processor. Check that this list corresponds to the 
   properties you defined in your implementation. The property values should be 
   the default values you have defined in your ``getParameterInfo`` :ref:`static 
   method<sec-afe-static-methods>`. If a property is missing, then you forgot to 
   list it in the beginning of your class definition (or you defined it as 
   ``Hidden`` or ``Private``). If a value is incorrect, or empty, then it is a 
   mistake in your ``getParameterInfo`` method. In addition, the ``Type`` 
   property should refer to the ``name`` field returned by ``getProcessorInfo`` 
   static method.
#. Inspect the external parameters of the processor by typing ``p.parameters``. 
   This should return a list of all external parameters. Control that all 
   parameters are there and that their default value is correct.

To test that your external properties are indeed dependent, you can change the
value of one or more of them directly in your ``parameter`` processor property
and see if that change is reflected on the dependent property. For example if
you type::

  p.parameters.map('xx_par1') = someRandomValue

then this should reflect in the property associated with that parameter.

.. note::
  
  The input and output frequencies properties of your processor, ``FsHzIn`` and
  ``FsHzOut`` are probably incorrect, but that is normal as you did not specify
  the sampling frequency when calling the constructor with no arguments.

Is it a valid processor?
~~~~~~~~~~~~~~~~~~~~~~~~

To test whether your processor is recognised as a valid processor, run the
``requestList`` script. The signal request name corresponding to your  processor
should appear in the list (i.e., the name defined in
``getProcessorInfo.requestName``). If not (and the previous test did work), then
maybe your class definition file is not located in the correct folder. Move it
to the ``src/Processors`` folder. Another possibility is that you made your
processor hidden (which should not happen if you followed these instructions).
Setting explicitly  the ``bHidden`` property of your processor to ``1`` will
hide it from the framework. This is used in order to allow "sub-processors" in
the framework, but it is probably not the case for you here so you should not
enable this option.


Are parameters correctly described?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your processor is recognised as valid, then you can call the
``parameterHelper`` script from the command window. There you should see a new
category corresponding to your processor. Clicking on it will display a list of
user-controllable parameters for your processor, as well as the description you
gave. Feel free to adjust your ``getParameterInfo`` static method to have more
suitable or better looking descriptions.



.. _sec-afe-processing-method:

Implement the core processing method
------------------------------------

At this stage, and if the previous tests were successfully passed, your
processor should be correctly detected by the |AFE| framework. However, there is
still some implementation work to do. In particular, the core of your processor,
the method which performs the processing of the input signal and returns a
corresponding output.

This section will provide guidelines as to how to implement that method.
However, this task is very dependent on the functionality you want your
processor to have. You can get insights as to how to perform the signal
processing task by looking at the code of the ``.processChunk`` methods of
existing processors. 

.. note::

  The problems faced here and some aspects to build solutions were already
  presented in a :ref:`section<sec-process-chunk>` of the technical description.
  It is recommended at that stage to go back and read that section again.

Input and output arguments
~~~~~~~~~~~~~~~~~~~~~~~~~~

The processing method should be called ``processChunk`` and be placed in a block
of methods with no attributes (e.g., following the class constructor). The
function takes a single effective input argument, a chunk of input signal and
returns a single output argument, the corresponding chunk of output signal.
Because it is a non-static method of the processor however, an instance of the
processor is passed as first input argument. Hence the method definition looks
something like this::

  function out = processChunk(pObj,in)

    % The signal processing to obtain "out" from "in" is written here
    %
    % ...

  end

Given an instance of your processor, say ``p``, this allows you to call this
method (and in general all methods taking an object instance as first argument)
in two different ways:

- ``processChunk(p,in)``
- ``p.processChunk(in)``

The two calls will of course return the same output.

Having an instance of the processor as an argument means that you can access all
of its properties to carry out the processing. In particular, the external and
internal parameter properties you have defined earlier.

The arguments ``in`` and ``out`` are arrays containing "pure" data. Although
signal-related data is stored as specific signal objects in the |AFE|, only the
data is passed around when it comes to processing. It is done internally and
with emphasis on avoiding unnecessary copies. So it is not something to address
in the implementation of your processing method. Your input is an array whose
dimensionality depends on the type of signal. Dimensions are ordered in the same
way as in the data-storing buffer of the signal object. For example, the input
``in`` in the ``gammatoneProc.processChunk`` is a one-dimensional array spanning
time. Similarly, the output should be arranged in the same way it is stored in
its corresponding output signal object. For example, the output ``out`` of
``modulationProc.processChunk`` is a three-dimensional array where the first
dimension spans time, the second spans audio frequency and the third spans
modulation frequency. Just like the way data is stored in the
``modulationSignal.Data`` buffer.

.. note::
  The first dimension for all signals used in the |AFE| is always spanning time.


Chunk-based and signal-based processing 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As the name of the method ``processChunk`` suggests, you should implement the
processing method such that it can process consecutive chunks of input signal,
as opposed to the entire signal at once. This is to enable "online" processing,
and later down the way "real-time" processing once the software has been
sufficiently optimised. This has two fundamental consequences on your
implementation:

1. The input data to the processing method can be of arbitrary duration.
2. The processing method need to respect continuity between input chunks. In 
   other words, when concatenating the outputs obtained by processing 
   individual consecutive chunks of input, one need to obtain the same output 
   as if all the consecutive input were concatenated and processed at once.

Point 1. above implies that depending on the type of processing you are carrying
out, it might be necessary to buffer the input signal. For example, processors
involving framing of the signal, such as ``ratemapProc`` or ``ildProc``, need to
put the segment of the input signal that went out of bound of the framing
operation in a buffer. This buffer is then appended to the beginning of the next
input chunk. This is illustrated in a :ref:`section<sec-ratemap-example>` of the
technical description of the framework. This also means that for some processor
(those which lower the sampling rate in general), an input that is too short in
time might produce an empty output. But this input will still be considered in
the next chunk.

Point 2. is the most challenging one. How to fulfil it depends entirely on what
your processor performs. Hence there are no specific guidelines. However, the
|AFE| comes with some building blocks to help with this task. It features for
instance filter objects that can be used for processing. All filters manage
their internal states themselves, such that output continuity is ensured. For an
example on how to use filters, see e.g. ``gammatoneProc.processChunk``.
Sometimes however, one need more than simple filtering operations. One can often
find a workaround by using some sort of "overlap-save" method using smart
buffering of the input or output as described in the :ref:`technical description
<sec-process-chunk>`. A good example of using buffering  for output continuity
can be found in e.g., ``ildProc.processChunk``.


Reset method
~~~~~~~~~~~~

To ensure continuity between output chunks, your new processor might include
"internal states" (e.g., built-in filter objects or internal buffers). Normally,
incoming chunks of input are assumed to be consecutive segments of a same
signal. However, the user can decide to feed an entirely new signal as input at
any time. If that is the case, then your processor should be able to reset its
internal states in order to start anew.

This is performed in the ``reset`` method. This method should be implemented as
the constructor in a method block with no method attributes. It should simply
reset the filters (if any) by calling all the filters ``reset`` methods, and/or
empty all internal buffers.

If your processor did not need any internal state storage, then the ``reset``
method should still be implemented (as it is an abstract method of the parent
class) but can be left empty (see, e.g., ``itdProc.reset``).


.. _sec-afe-override-methods:

Override parent methods
-----------------------

The |AFE| framework was developed such as to maximize code reusing. Many of the
existing processors, although they carry out different processing tasks, have
common attributes in terms of e.g., number of inputs, number of outputs, how to
call their processing methods, ... Hence all aspects of initialization (and re-
initialization following a response to feedback) and input/output routing have
been implemented for common-cases as methods of the parent ``Processor`` class.
If your processor does not behave similarly to others in one of these regards,
then this approach allows you to redefine the specific method in your new
children processor class definition. In the object oriented jargon, this is
called method overriding.

In the following, we list the methods that might need overriding and how to do
so. Subsections for each methods will start with a description of what the
method does and a note explaining in which cases the method needs to be
overridden, such that you can quickly identify if this is necessary for your
processor or not. Some examples of existing processors that override a given
method will also be given so they can be used as examples.

.. note::

  Overridden methods need to have the same method attribute(s) as the parent
  method they are overriding.

Initialization methods
~~~~~~~~~~~~~~~~~~~~~~

``verifyParameters``
^^^^^^^^^^^^^^^^^^^^

This method is called at the end of the ``Processor`` super-constructor. It
allows to control that user-provided parameters are suitable. The current
implementation of the |AFE| relies a lot on the user being responsible and aware
of which type or values are suitable for a given parameter. Therefore, we do not
perform a systematic check on all parameters. Sometimes though, you might want
to verify that user-provided parameters are correct in order to avoid Matlab
returning an error at a later stage. For example, ``ihcProc.verifyParameters``
will check that the inner hair-cell model name entered by the user is part of
the list of valid names.

Another use for the ``verifyParameters`` method is to solve conflicts between
parameters. For example, the auditory filterbank in ``gammatoneProc`` can be
instantiated in three different ways (e.g., by providing a range of frequency
and a number of channels, or directly a vector of centre frequencies). The user-
provided parameters for this processor are therefore potentially "over-
determining" the position of centre frequencies. To make sure that there is no
conflict, some priority rules are defined in ``gammatoneProc.verifyParameters``
to ensure that a unique and non-ambiguous vector of centre frequencies is
generated.

.. note::

  This method does nothing by default. Override it if you need to perform
  specific checks on external parameters (i.e., the user-provided parameters
  extended by the default values) before instantiating your processor.

To override this method, place it in a methods block with the
``Access=protected`` attribute. The method takes only an instance of the
processor object (say, ``pObj``) as input argument, and does not return any
output.

If you are checking that parameters have valid values, replace those which are
invalid with their default value in ``pObj.parameters.map`` (see e.g.,
``ihcProc.verifyParameters``). It is a good practice here to inform the user by
returning a warning, so that he/she knows that it is not the value they intended
that is actually used.

If you are solving conflicts between parameters, set up a priority rule and only
retain user-provided parameters that have higher priority according to this rule
(see e.g., ``gammatoneProc.verifyParameters``). Mention explicitly this rule in
the help line of your processor constructor.


``prepareForProcessing``
^^^^^^^^^^^^^^^^^^^^^^^^

This method performs the remaining initialization steps that we purposely did
not include in the constructor as they initialized properties that are
susceptible to change when receiving feedback. This method will be called at
instantiation, but also whenever feedback affecting that processor is received.

.. note::

  Override this method if your processor has properties or internal parameters
  that can be changed via user feedback. For example, framing windows or
  filters.

This method should have the ``Hidden=true`` method attribute. Hidden methods are
sometimes used in the |AFE| when we need public access to it (i.e., other
objects than the processor itself should be able to call the method) but when it
is not deemed necessary to have the user call it. The user can still call the
method by explicitly writing its name, but the method will not appear in the
list of methods returned by Matlab script ``methods(.)`` nor by Matlab's
automatic completion.

The method only takes an instance of the processor as input argument and does
not return outputs. In the method, you should initialize all internal parameters
that are susceptible to change from user feedback. Note that this includes the
processor's output sampling frequency ``FsHzOut`` if this frequency depends on
the processor parameters. A good example here is
``ratemapProc.prepareForProcessing``, which initializes internal parameters
(framing windows), the output sampling frequency and some filters.


``instantiateOutput``
^^^^^^^^^^^^^^^^^^^^^

This method is called just after a processor has been instantiated to create a
signal object that will contain the output of this new processor and add the
signal to the data object.

.. note::

  Override this method if your output signal object constructor needs additional input arguments (e.g., ``FeatureSignal``)

Input/output routing methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``addInput``
``addOutput``

Processing method
~~~~~~~~~~~~~~~~~

``initiateProcessing``
``update``

.. _sec-afe-alternative-processing:

Allowing alternative processing options
---------------------------------------

.. _sec-afe-new-signal:

Implement a new signal type
---------------------------

.. _sec-afe-final-testing:

Recommendations for final testing
---------------------------------

- Test batch vs. chunk processing