.. _sec-afe-add-processor:

Add your own processors
=======================

.. vim: filetype=rst spell:

The |AFE| framework has been designed such as to be easily upgraded. To add a 
new processor, write its class definition in a new ``.m`` file and add it to 
the ``/src/Processors`` folder. If correctly written, the processor should be 
detected by the framework and be ready to use. This section documents in 
details how to correctly write the class definition of a new processor. It is 
highly recommended to look into the definition of existing processors to get 
a grasp of how classes are defined and written in Matlab. In the following, we 
will sometimes refer to a particular existing processor to illustrate some 
aspects of the implementation.

.. note::
    
    - The following descriptions are exhaustive, and adding a processor to the
      framework is actually easier than the length of this page suggests!
    - This tutorial is written assuming close to no knowledge about object-
      oriented programming using Matlab. Hence most 
      :abbr:`OOP(object-oriented programming)` concepts involved are briefly 
      explained. If you are already familiar with them, then the process should 
      be relatively painless.

.. _sec-afe-addition-checklist:

Check-list for adding a new processor
-------------------------------------

To write the class definition for a new processor such that it will be 
recognised and properly integrated, one has to follow these steps:

1. :ref:`Set up the specific properties of the processor class <sec-afe-class-properties>`
#. :ref:`Implement the processor's static methods <sec-afe-static-methods>`
#. :ref:`Implement the processor's abstract methods (processing and resetting) <sec-afe-processing-method>`
#. :ref:`Implementing parameters "getter" methods <sec-afe-getter-methods>`
#. :ref:`Implement the processor constructor <sec-afe-processor-constructor>`
#. :ref:`Take a break and test your implementation <sec-afe-preliminary-testing>`
#. :ref:`Implement the core processing method <sec-afe-processing-method>`
#. :ref:`Override parent methods (optional) <sec-afe-override-methods>`
#. :ref:`Allowing alternative processing options (optional) <sec-afe-alternative-processing>`
#. :ref:`Add a new type of signal (optional)<sec-afe-new-signal>`
#. :ref:`Final testing <sec-afe-final-testing>`

.. _sec-afe-class-properties:

Getting started and setting up processor properties
---------------------------------------------------

The properties of an object are a way to store data used by the object. There
are two types of properties for processors, those which:

- store all the parameters needed to integrate the processor in the framework 
  (e.g., the sampling frequency on which it operates, the number of 
  inputs/outputs, ...)
- store parameter values which are used in the actual processing

When writing the class definition for a new processor, it is only necessary to
implement the latter: parameters which are needed in the computation. All
parameters needed for the integration of the processor in the framework are
already defined in the parent ``Processor`` class. Your new processor should
inherit this parent class in order to automatically have access to the
properties and methods of the parent class. Inheritance in Matlab is indicated
by the command ``< nameOfParentClass`` following the name of your new class on
the first line of its definition.

.. Maybe we could set up a template file, i.e., a blank processor with basic guidelines on how to populate the blanks

The new processor class definition should be saved in a ``.m`` file that bears
the same name as the defined class. In the example below, that would be
``myNewProcessor.m``.

There are usually two categories of properties to implement for a new processor:
external (user-controlled) parameters and internal parameters necessary for the
processor but which do not need to be known to the "outside world".

.. note::

    Only the two types of properties below have been used so far in every
    processor implementation. However, it is fine to add more if needed for your
    new processor.

External parameters controllable by the user
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

External parameters are directly related to the parameters the user has control
upon. The actual values for these are stored in a specific object accessible via
the ``.parameters`` property of the processor. Defining them as individual
properties seems redundant, and is therefore optional. However it can be very
convenient in order to simplify the access to the parameter value and to make
your code more readable.

Instead of storing an actual value, the corresponding processor property should
only point to a value in the ``.parameters`` object. This will avoid having two
different values for a same parameter. To do this, external parameters should be
defined as a set of dependent properties. This is indicated by the ``Dependent =
true`` property attribute. If a property is set to ``Dependent``, then a
corresponding "getter" method has to be implemented for it. This will be
developed :ref:`in a following section<sec-afe-getter-methods>`. For example,
if your new processor has two parameters, ``parA`` and ``parB``, you can define
these as properties as follow::


    classdef myNewProcessor < Processor

      properties (Dependent = true)
        parA;
        parB;
      end

      %...

    end

This will allow easier access to these values in your code. For example,
``myNewProcessor.parA`` will always give the same output as
``myNewProcessor.parameters.map('xx_nameTagOfParameterA')``, even if the
parameter value changes due to feedback. This simplifies greatly the code,
particularly when many parameters are involved.


Internal parameters
~~~~~~~~~~~~~~~~~~~

Internal parameters are sometimes (not always) needed for the good functioning
of the processor. They are typically used to store internal states of the
processor (to allow continuity in block-based processing), filter instances (if
your processor involves filtering), or just intermediate parameter values used
to make code more readable.

Because they are "internal" to the processor, these parameters are usually
stored as a set of private properties by using the ``GetAccess = private``
property attributes. This will virtually make the property invisible and
inaccessible to all other objects.

.. _sec-afe-static-methods:

Implementing static methods
---------------------------

Static methods are methods that can be called without an existing instance of an
object. In the implementation of processors, they are used to store all the
hard-coded information. This can be for example the processor name, the type of
signal it accepts as input, or the names and default values of its external
parameters. To implement a static method, define it in a method block with the
``(Static)`` method attribute::


    classdef myNewProcessor < Processor

      % ... Properties and other methods definition

      methods (Static)

        function out = myStaticMethod_1(in)
          %...
        end

        function out = myStaticMethod_2(in)
          %...
        end

      end

    end

Static methods share the same structure and names across processors, so they can
easily be copy/pasted from an existing processor and then modified to reflect
your new processor. The following three methods have to be implemented.

- ``.getDependency()``: Returns the type of input signal by its user request 
  name
- ``.getParameterInfo()``: Returns names, default values, and descriptions of 
  external parameters
- ``.getProcessorInfo()``: Returns information about the processor as a Matlab 
  structure

As they are used to hard-code and return information, none of these methods 
accept input arguments.

``getDependency``
~~~~~~~~~~~~~~~~~

This method returns the type of input signal your processor should accept::

    function name = getDependency()
      name = 'requestNameOfInputSignal';
    end

where ``'requestNameOfInputSignal'`` is the request name of the signal that
should be used as input. "Request name" corresponds to the request a user would
call in order to obtain that signal. For example, the inner hair-cell envelope
processor requires as input the output of e.g., a gammatone filterbank. The
request name for this signal is ``'filterbank'`` which should therefore be the
output of the static method ``ihcProc.getDependency()``.

If you are unsure about which name should be used, consider which processor
would come directly before your new processor in a processing chain (i.e., the
processor your new processor depends on). Say it is named ``dependentProc``.
Then typing::

    dependentProc.getProcessorInfo.requestName

in Matlab's command window will return the corresponding request name you should
output in your ``getDependency`` method.

``getParameterInfo``
~~~~~~~~~~~~~~~~~~~~

This method hard-codes all information regarding the (external) parameters used
by your processor, i.e., lists of their names, default values, and description.
These are used to populate the output of the helper script ``parameterHelper``
and to give a default value to parameters when your processor is instantiated.

The lists are returned as cell arrays of strings (or any other type for the
default parameter values). They should follow the same order, such that the n-th
member of each of the three lists relate to the same parameter.

Parameter names need not be the same as the parameter properties names you
defined :ref:`earlier<sec-afe-class-properties>`. This will become apparent in
the :ref:`next section<sec-afe-getter-methods>`. In fact, names should be
changed to at least include a two or three letters prefix that is unique to your
new processor. You can make sure it is not already in use by browsing through
the output of the ``parameterHelper`` script.

The method should look something like this::

    function [names,defValues,description] = getParameterInfo()

      names = {'xx_par1','xx_par2','xx_par3'};

      defValues = {0.5, ...
                   [1 2 3 4], ...
                   'someStringValue'};

      description = {'Tuning factor of dummy example (s)',...
                     'Vector of unused frequencies (Hz)',...
                     'Model name (''someStringValue'' or ''anotherValue'')'}

    end

This dummy example illustrates the following important points:

- Use a unique prefix in the name of the parameters (``xx_`` above) that 
  abbreviates the name or task of the processor.
- Find a short, but self-explanatory parameter name (*not* like ``parX`` above).
  If it makes sense, you can re-use the same name as a parameter involved in 
  another processor. The prefix will make the name unique.
- Default values can be of any type (e.g., float number, array, strings,...)
- Descriptions should be as short as possible while still explanatory. Mention 
  if applicable the units or the different alternatives.

``getProcessorInfo``
~~~~~~~~~~~~~~~~~~~~

This method stores the properties of the processor that are needed to integrate
it in the framework. It outputs a structure with the following fields:

- ``.name``: A short, self-explanatory name for the processor
- ``.label``: A name for the processor that is used as a label. It can the same 
  as ``.name`` if that is sufficient, or a bit longer if needed.
- ``.requestName``: The name tag of the request that a user should input when 
  calling the ``.addProcessor`` method of the manager. *Cannot* include spaces.
- ``.requestLabel``: A longer name for the signal this processor produces, used 
  e.g., as plot labels.
- ``outputType``: The type of signal object (name of the class) this processor 
  produces. If none of the existing signals in the framework are suitable, you 
  will need to :ref:`implement a new one<sec-afe-new-signal>`.
- ``isBinaural``: Set to 0 if your processor operates on a single channel (e.g.,
  an auditory filterbank) or to 1 if it *needs* a binaural input (e.g., the 
  inter-aural level differences processor). If your processor can indifferently 
  operate on mono or stereo signals (such as the pre-processor ``preProc.m``), 
  set to 2.

Your method should initialize the structure that will be returned as output and
give a value to all of the above-mentioned fields::

  %...

  function pInfo = getProcessorInfo

    pInfo = struct;

    pInfo.name = 'MyProcessor';
    pInfo.label = 'Processor doing things';
    % etc...

  end


.. _sec-afe-getter-methods:

Implementing parameters "getter" methods
----------------------------------------

As described in an :ref:`earlier section<sec-afe-class-properties>`, external
parameters of the processor, i.e., those that can be modified by the user, were
implemented as ``Dependent`` properties of your processor class. For your
implementation to be valid, a "getter" method needs to be implemented for each
of these parameters. If not, Matlab will generate an error when trying to access
that parameter value. If a property is set as ``Dependent``, then its getter
method will be called whenever the program try to access that property. In
general, this can be useful for a property that *depends* on others and that
need to be recomputed whenever accessed. In the present case, we will set the
getter method to read the corresponding parameter value in the parameter object
associated with your processor. If the value of the parameter has changed
throughout the processing (e.g., in response to feedback), then we are sure to
always get the updated value.

"Getter" methods for parameters are implemented without any method attribute and
always follow the same structure. Hence they can easily be copy/pasted and
adjusted::

    methods

      function value = get.parName(pObj)
        value = pObj.parameters.map('xx_parNameTag')
      end

      % ... implement one get. method for each parameter

    end

In the above example, ``parName`` is the name of the parameter as a dependent
*property* of your processor class, and ``xx_parNameTag`` is the name of the
parameter as the user accesses it and as is defined in the :ref:`static<sec-afe-static-methods>`
``.getParameterInfo`` method. ``pObj`` represents an instance of your processor
class, it does not need to be changed across methods.


.. _sec-afe-processor-constructor:

Implement the processor constructor
-----------------------------------

For any possible application, every concrete classes one defines in Matlab
should implement a very specific method: a class constructor. A class
constructor is a function that bears the exact same name as your class, that can
take any combination of input arguments but that can return only a single
output: an "instance" of your class.

In the |AFE| architecture however, the input arguments to the constructor of all
processors have been normalized, such that all processor constructors can be
called using the exact same arguments. The input arguments should be (in this
order) the sampling frequency of the input signal to the processor and an
instance of parameter object returned e.g. by the script ``genParStruct.m``. The
constructor's role is then to create an object of the class, and often to
initialize all its properties. Most of this initialization step is the same
across all processors (e.g., setting input/output sampling frequencies,
indicating the type of processor, ...). Hence all processor constructors rely
heavily on the constructor of their parent class (or super-constructor),
``Processor(...)`` which defines these across-processors operations. This allows
to have all this code in one place which reduces the code you have to write for
your processor, as well as reducing chances for bugs and increasing
maintainability. This concept of "inheritance" will be further taken advantage
of in a :ref:`further section<sec-afe-override-methods>`.

In practice, this means that the constructor for your processor will be very
short:

.. code-block:: Matlab
    :linenos:

    function pObj = myNewProcessor(fs,parObj)
      %myNewProcessor   ... Provide some help here ...

      if nargin<2||isempty(parObj); parObj = Parameters; end
      if nargin<1; fs = []; end

      % Call super-constructor
      pObj = pObj@Processor(fs, fsOut,'myNewProcessor',parObj);

      % Additional code depending on your processor
      % ...

    end


.. note::

    The constructor method should be placed in a "method" block with no method 
    attribute.

Let us break down the constructor structure line by line:

- *Line 1*: As stated earlier, all processor constructors take two input and 
  return a single output, your processor instance ``pObj``. Matlab restricts all 
  constructors to return a single output. If for any reason you need additional 
  information as output, you would have to place it in a property of your 
  processor instead of a regular output. Input arguments are the **input** 
  sampling frequency, i.e., the sampling frequency of the signal at the input of 
  the processor, and a parameter object ``parObj``.
- *Line 2*: This is where you will place help regarding how to call this 
  constructor. Because they have a generic form across all processors, you can 
  easily copy/paste it from another processor.
- *Lines 4 and 5*: An important aspect in this implementation is that the 
  constructor should be called with no input argument and still return a valid 
  instance of the processor, without any error. Hence these two lines define 
  default values for inputs if none were specified.
- *Line 8*: This line generates a processor instance by calling the class 
  super-constructor. The super-constructor takes four inputs: 

  - the **input** sampling frequency ``fs``
  - the **output** sampling frequency. If your processor does not modify the 
    sampling rate, then you can replace ``fsOut`` with ``fs``. If the output 
    sampling rate of your processor if **fixed**, i.e., not depending on 
    external parameters, then you can specify it here, in place of ``fsOut``. 
    Lastly, if the output sampling rate depends on some external parameters 
    (i.e., susceptible to change via feedback from the user), then you should 
    leave the ``fsOut`` field empty: ``[]``. The output sampling rate will be 
    defined in :ref:`another method<sec-afe-override-methods>` that is called 
    every time feedback is involved.
  - the name of the children processor, here ``myNewProcessor``.
  - the parameter object ``parObj`` already provided as input.

- *Line 11*: Your processor might need additional initialization. All extra code
  should go there. To ensure that no error is generated when calling the 
  constructor with no arguments (which Matlab sometimes does implicitly), the 
  code should be embedded in a ``if nargin > 0 ... end`` block. Here you can 
  for example initialize buffers or internal properties.

.. warning::

    The initialization of anything that depends on external parameters (e.g.,
    filters, framing windows, ...) is not performed here on line 11. When 
    parameters change due to feedback, these properties need to be 
    re-initialized. Hence their initialization is performed in another method 
    that will be described in a 
    :ref:`following section<sec-afe-override-methods>`.



.. _sec-afe-preliminary-testing:

Preliminary testing
-------------------

At this stage of the implementation, your processor should be correctly
instantiated and recognised by the framework. In some cases (e.g., your
processor is a simple single input / single output processor), it might even be
correctly integrated and routed to other processors. In any case, now is a good
time to take a break from writing code and do some preliminary testing. We will
go through a few example tests you can run, which problems could arise and some
suggestions as to how to solve them. Try to run these tests in the order they
are listed below, as this will help troubleshooting. They should run as expected
before you go further in your implementation.

Default instantiation
~~~~~~~~~~~~~~~~~~~~~

As mentioned when 
:ref:`implementing the constructor<sec-afe-processor-constructor>`, you should 
be able to get a valid instance of your processor by calling its constructor 
without any input arguments::

  >> p = myNewProcessor

If this line returns an error, then you have to revise your implementation of
the :ref:`constructor<sec-afe-processor-constructor>`. The error message should
indicate clearly enough where the problem is, so that you can easily correct it.
Note that it is necessary for this test to pass for your processor to be
integrated in the framework. If it cannot be instantiated with no arguments,
then it will not be listed as a valid processor.

If on the other hand this line executed without error, then there are two things
you should control:

1. The line above (if not ended by a semicolon) should display the visible, 
   public properties of the processor. Check that this list corresponds to the 
   properties you defined in your implementation. The property values should be 
   the default values you have defined in your ``getParameterInfo`` :ref:`static 
   method<sec-afe-static-methods>`. If a property is missing, then you forgot to 
   list it in the beginning of your class definition (or you defined it as 
   ``Hidden`` or ``Private``). If a value is incorrect, or empty, then it is a 
   mistake in your ``getParameterInfo`` method. In addition, the ``Type`` 
   property should refer to the ``name`` field returned by ``getProcessorInfo`` 
   static method.
#. Inspect the external parameters of the processor by typing ``p.parameters``. 
   This should return a list of all external parameters. Control that all 
   parameters are there and that their default value is correct.

To test that your external properties are indeed dependent, you can change the
value of one or more of them directly in your ``parameter`` processor property
and see if that change is reflected on the dependent property. For example if
you type::

  p.parameters.map('xx_par1') = someRandomValue

then this should reflect in the property associated with that parameter.


Is it a valid processor?
~~~~~~~~~~~~~~~~~~~~~~~~

To test whether your processor is recognised as a valid processor, run the
``requestList`` script. The signal request name corresponding to your  processor
should appear in the list (i.e., the name defined in
``getProcessorInfo.requestName``). If not (and the previous test did work), then
maybe your class definition file is not located in the correct folder. Move it
to the ``src/Processors`` folder. Another possibility is that you made your
processor hidden (which should not happen if you followed these instructions).
Setting explicitly  the ``bHidden`` property of your processor to ``1`` will
hide it from the framework. This is used in order to allow "sub-processors" in
the framework, but it is probably not the case for you here so you should not
enable this option.


Are parameters correctly described?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your processor is recognised as valid, then you can call the
``parameterHelper`` script from the command window. There you should see a new
category corresponding to your processor. Clicking on it will display a list of
user-controllable parameters for your processor, as well as the description you
gave. Feel free to adjust your ``getParameterInfo`` static method to have more
suitable or better looking descriptions.



.. _sec-afe-processing-method:

Implement the core processing method
------------------------------------



.. _sec-afe-override-methods:

Override parent methods
-----------------------

.. _sec-afe-alternative-processing:

Allowing alternative processing options
---------------------------------------

.. _sec-afe-new-signal:

Implement a new signal type
---------------------------

.. _sec-afe-final-testing:

Recommendations for final testing
---------------------------------

