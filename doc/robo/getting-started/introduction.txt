Introduction
============

.. contents::
    :local:

.. _sec-cbsa:

Component-based software architectures in robotics
--------------------------------------------------

Robots are highly complex systems that embed numerous sensors and actuators, in
the service of a variety of algorithms performing heterogeneous tasks. They
often have to deal with severe requirements (timing constraints, limited energy,
memory and processing resources...) and must show a robust conception as
uncertainty about their environment is high, and unexpected events can have
critical consequences.

To facilitate the development of robotic software, **component-based
architectures**, where components are independent processes, have become the
*de facto* standard in robotics. Each software component is dedicated to a given
task, from low-level control to high-level processing. They communicate with
each other with the help of a software piece called the **middleware**.

For instance, consider a robot embedding a camera and performing object
detection in the images. One component could be in charge of acquiring the
images using the camera's driver, and would output these data. Another component
could input the images and run an algorithm to detect objects, producing the
detection result as output for any other component in need of this
information. Routing data from the output of the first component to the input of
the second one is ensured by the middleware, this is called **data flow**.

Components offer **services** to the user to modify their behaviour and adapt to
different situations. To follow with the example above, the component acquiring
images could have a service to select which camera to use, another one to
configure parameters such as the image size and the number of frames per second,
a third one to explicitly request the start of the acquisition, *etc.* The
component detecting objects could have a service to change some parameters in
the detection algorithm, another one to choose which image stream to take as
input (because there could be several components streaming images from different
cameras), *etc.* Making services available to the user is again handled by the
middleware, this is called **control flow**.

.. note::

    The *user* mentioned here is not necessarily a physical person. For
    autonomous robots, it will probably be a detached software piece,
    supervising the state of the robot and choosing to start a given service to
    accomplish a new goal it has identified. This software piece belongs to the
    **decisional level**, while other components make up the **functional
    level**.


Component-based software architectures offer great benefits in robotics, in
particular [1]_:

Modularity
    * As many operations handled by a robot require to have their own thread of
      execution (*e.g.* data acquisition for sensors and motion control for
      actuators), having them in separated programs facilitates their concurrent
      execution.
    * The architecture can be adapted to the needs of the robot: adding a new
      hardware piece such as a sensor will simply result in running a new
      software component to drive it.
    * The system can be distributed over a network, the middleware seamlessly
      ensuring communication between components running on different host
      machines.

Re-usability
    * Common components can be used across robots without having to recode them
      from scratch.
    * Components can be packaged and easily shared in the robotics community,
      where open source software prevails.
    * Re-usable components reduce cost and time as well as improve software
      quality and sustainability.

|ROS|, a software platform for robotics
---------------------------------------

The :ref:`previous section <sec-cbsa>` identifies the *middleware* as the
software piece ensuring data flow between functional components, and allowing
their control.

|ROS| is a widely known software platform in robotics, providing not only a
middleware, but also implementing a wide range of commonly-used functionalities
into software components (such as localization, mapping, path-planning, obstacle
avoidance, *etc.*), with a build system and a packaging system for easy
compilation and installation. |ROS| benefits from a large community of users and
developers, and runs on many robots today. This makes |ROS| a common choice as a
software platform, as it is for |TwoEars|.


|ROS| embraces the principles of component-based software architectures,
allowing distributed computation, software reuse and rapid testing [2]_. If you
will be a user of a robotic platform running |ROS|, the `core tutorials
<http://wiki.ros.org/ROS/Tutorials>`_ can help you to get familiar with the
|ROS| environment. The main |ROS| terminology, introduced in the tutorials, is
recalled here:

Nodes
    Software components using |ROS| middleware are called |ROS| **nodes**.

Topics and messages
    Data flows are called **topics**. A node that outputs data *publishes* on
    a topic. A node that inputs data *subscribes* to a topic. The data
    elements flowing on topics are called **messages**.

Services and actions
    Nodes can provide **services** to control them. Some special services that
    can take a long time to execute are called **actions**.

.. note::

    In spite of its name, |ROS| does not replace, but instead works alongside a
    traditional operating system. As it provides features such as hardware
    abstraction and low-level device control [3]_, |ROS| has some similarities
    with an :abbr:`OS (Operating System)`, hence its name.

|GenoM3|, a tool to develop robotic components
----------------------------------------------

.. warning::

    Section TBD.

.. [1]
    A\. Brooks, T. Kaupp, A. Makarenko, S. Williams, and A. Ore- back. Towards
    component-based robotics. In *IEEE Interna- tional Conference on Intelligent
    Robots and Systems*, pages 163â€“168, Tsukuba (Japan), 2005.

.. [2]
    Jason M. O'Kane. A Gentle Introduction to
    ROS. http://www.cse.sc.edu/~jokane/agitr/, 2014.

.. [3]
    http://wiki.ros.org/ROS/Introduction

.. vim: filetype=rst spell:
.. emacs:
   Local Variables:
   mode: rst
   fill-column: 80
   End:
